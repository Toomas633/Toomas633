# Backend Copilot Instructions - Toomas633's Dungeon

## Project Overview

- **Name:** "Toomas633's Dungeon" Backend (v4.2.1)
- **Stack:** Node.js 24+ with Express.js and TypeScript using ESM modules
- **Purpose:** Backend API server providing email functionality for the frontend homepage
- **Architecture:** Modular Express server with TypeScript types, middleware, services, and utility layers

## Technical Stack & Dependencies

### Core Technologies

- **Runtime:** Node.js 24+ (LTS recommended)
- **Language:** TypeScript 5.7+ with strict type checking
- **Framework:** Express.js 5.x with TypeScript types and ESM modules
- **Email:** Nodemailer with TypeScript type definitions
- **Security:** CORS protection, rate limiting, environment validation
- **Development:** tsx for fast TypeScript execution, TypeScript compiler for production builds

### Key Dependencies

- **express** (5.x): Web framework with TypeScript type definitions
- **nodemailer** (7.x): SMTP email transport with types
- **cors** (2.x): Cross-origin resource sharing middleware
- **express-rate-limit** (8.x): Rate limiting for API endpoints
- **body-parser** (2.x): JSON request parsing
- **dotenv** (17.x): Environment variable management

### Development Dependencies

- **typescript** (5.7+): TypeScript compiler and language support
- **tsx** (4.x): Fast TypeScript execution for development
- **@types/\*** TypeScript type definitions for all dependencies
- **@typescript-eslint/\*** TypeScript-specific ESLint plugins
- **rimraf**: Cross-platform directory cleaning utility

### TypeScript Configuration (`tsconfig.json`)

- **Target:** ES2022 for modern Node.js features
- **Module System:** ESNext with Bundler module resolution
- **Strict Mode:** Enabled for maximum type safety
- **Output:** Compiled to `dist/` directory with source maps
- **Declaration Files:** Disabled (set to false for faster builds)
- **Source Maps:** Enabled for debugging
- **Import Resolution:** `.js` extensions required in imports (Node.js ESM requirement)

## Project Structure & Patterns

### Directory Organization

```
backend/
├── src/                       # TypeScript source files
│   ├── app.ts                 # Express app configuration and middleware setup
│   ├── server.ts              # Server startup, graceful shutdown, health verification
│   ├── config/
│   │   └── env.ts            # Environment validation and typed configuration exports
│   ├── middleware/
│   │   ├── cors.ts           # CORS configuration with allowed origins
│   │   └── rateLimiter.ts    # Rate limiting configuration
│   ├── routes/
│   │   ├── health.ts         # Health check endpoint with email verification
│   │   └── email.ts          # Email sending endpoint with validation
│   ├── services/
│   │   └── emailService.ts   # Nodemailer transport and email operations
│   ├── types/
│   │   └── index.ts          # TypeScript type definitions and interfaces
│   └── utils/
│       └── helpers.ts        # Utility functions (logging, object formatting)
├── dist/                      # Compiled JavaScript output (gitignored)
├── package.json               # Dependencies and TypeScript build scripts
├── tsconfig.json             # TypeScript compiler configuration
├── eslint.config.js          # ESLint configuration for TypeScript
├── Dockerfile                # Production container image with TypeScript build
├── docker-compose.yml        # Development container setup
└── README.md                 # Setup and deployment documentation
```

### Module System & Imports

- **TypeScript + ESM:** All files use `.ts` extension with `"type": "module"` and TypeScript compilation
- **Import Style:** Use named imports `{ config }` and default exports consistently with TypeScript types
- **Path Resolution:** Relative paths for internal modules with `.js` extensions (required for Node.js ESM)
- **Type Imports:** Use `import type` for type-only imports to optimize bundle size

## Code Patterns & Conventions

### File Structure Patterns

```typescript
// Route file pattern (routes/*.ts)
import { Router } from 'express'
import type { Request, Response } from 'express'
import { serviceFunction } from '../services/serviceFile.js'
import { middlewareFunction } from '../middleware/middlewareFile.js'
import type { ApiResponse } from '../types/index.js'

const router = Router()

router.method(
	'/endpoint',
	middleware,
	async (req: Request, res: Response<ApiResponse>) => {
		// Route logic with TypeScript types
	}
)

export default router

// Service file pattern (services/*.ts)
import dependency from 'dependency'
import type { DependencyType } from 'dependency'
import { config } from '../config/env.js'
import type { ServiceParams, ServiceResult } from '../types/index.js'

export const serviceFunction = async (
	params: ServiceParams
): Promise<ServiceResult> => {
	// Service logic with typed parameters and return values
}

// Middleware file pattern (middleware/*.ts)
import middleware from 'middleware-package'
import { config } from '../config/env.js'

export const middlewareName = middleware(options)
```

### Error Handling Patterns

- **Route Level:** Try-catch blocks with structured error responses
- **App Level:** Global error middleware with logging and 500 responses
- **Service Level:** Throw errors with descriptive messages
- **Async/Await:** Preferred over promises, no callback patterns

### Configuration Management

- **Environment Variables:** Required vars validated at startup in `config/env.ts`
- **Configuration Export:** Single config object with typed interfaces
- **Validation:** Process exits with error if required env vars missing
- **Security:** No sensitive data in code, all secrets via environment

### TypeScript Type Definitions

- **Centralized Types:** All interfaces and types defined in `src/types/index.ts`
- **Configuration Types:** `AppConfig`, `EmailConfig`, `ServerConfig` interfaces
- **API Response Types:** `ApiResponse<T>`, `ErrorResponse` for consistent responses
- **Request/Response Types:** Typed Express request and response objects
- **Service Types:** Typed parameters and return values for all service functions

### Logging & Monitoring

- **Custom Logger:** `logWithTimestamp()` utility with levels (info, warn, error)
- **Health Checks:** `/health` endpoint with email service verification
- **Error Logging:** All unhandled errors logged with full context
- **Request Logging:** Minimal logging, focus on errors and health

## API Design Patterns

### Route Structure

- **RESTful:** Use appropriate HTTP methods and status codes
- **Middleware:** Apply middleware at route level (rate limiting, validation)
- **Response Format:** Consistent JSON structure for success and error
- **Error Responses:** Include success boolean, message, and relevant data

### Response Patterns

```typescript
// Success Response (typed)
res.status(200).json({
	success: true,
	data: result,
	info: additionalInfo,
} as ApiResponse)

// Error Response (typed)
res.status(500).json({
	success: false,
	message: 'Error description',
	error: errorDetails,
} as ApiResponse)

// Health Check Response (typed)
res.status(200).json({
	status: 'healthy',
	timestamp: new Date().toISOString(),
	email: {
		status: 'connected',
		responseTime: `${duration}ms`,
	},
} as HealthResponse)
```

### Security Implementations

- **CORS:** Configured with specific allowed origins, not wildcard
- **Rate Limiting:** 10 requests per 15 minutes for email endpoint
- **Headers:** Express powered-by header disabled
- **Input Validation:** Request body validation for required fields

## Email Service Architecture

### Service Layer (`emailService.ts`)

- **Transporter Factory:** `createTransporter(): Transporter` - Creates Nodemailer transport with typed return
- **Connection Verification:** `verifyEmailConnection(transporter: Transporter): Promise<number>` - Tests SMTP connection with timing
- **Email Sending:** `sendEmail(params: SendEmailParams): Promise<SentMessageInfo>` - Sends contact form emails with reply-to

### Configuration

```typescript
// SMTP Configuration Pattern (from config/env.ts)
interface EmailConfig {
	host: string
	user: string
	password: string
	to: string
	port: number
	requireTLS: boolean
}

// Email sending parameters
interface SendEmailParams {
	from: string
	message: string
	project: string
}

// Nodemailer configuration
{
	host: config.email.host,
	port: config.email.port,
	requireTLS: config.email.requireTLS,
	auth: {
		user: config.email.user,
		pass: config.email.password
	}
}
```

## Development & Deployment

### Scripts & Commands

```bash
# Development
npm run dev          # Fast development with tsx (no build step)
npm run dev:build    # Development with TypeScript compilation + watch
npm run build        # Compile TypeScript to JavaScript
npm run type-check   # Type checking without compilation
npm start           # Production start (runs compiled JS)

# Code Quality
npm run lint        # TypeScript-aware ESLint check
npm run lint:fix    # ESLint auto-fix
npm run format      # Prettier code formatting (TypeScript files)
npm run clean       # Remove compiled output directory

# Docker
npm run docker:build   # Build container image with TypeScript compilation
npm run docker:up      # Start development compose
npm run docker:down    # Stop containers
```

### Environment Configuration

```bash
# Required Environment Variables
EMAIL_HOST=smtp.example.com
EMAIL_USER=user@example.com
EMAIL_PASS=password
EMAIL_TO=contact@example.com
ALLOWED_ORIGINS=https://example.com,https://www.example.com
PORT=3000
```

### ESLint & Prettier Configuration

- **TypeScript Integration:** Uses @typescript-eslint parser and plugin
- **Style:** Single quotes, no semicolons, tab indentation, trailing commas
- **TypeScript Rules:** Type-aware linting, no explicit any warnings, unused vars checking
- **Node.js:** Configured for Node.js globals and TypeScript ES modules
- **File Coverage:** Only lints TypeScript files in src directory

## Docker & Production Patterns

### Container Configuration

- **Multi-stage Build:** Separate build stage for TypeScript compilation
- **Base Image:** `node:24-slim` with curl for health checks
- **Build Process:** TypeScript compilation in build stage, production dependencies in runtime
- **Security:** Non-root user (nodeuser), minimal system packages
- **Health Check:** Automatic `/health` endpoint monitoring
- **Port:** Exposes 3000, configurable via PORT environment variable

### Production Considerations

- **Process Management:** Graceful shutdown handling (SIGTERM/SIGINT)
- **Health Monitoring:** Built-in health endpoint with email service verification
- **Security:** Environment validation, CORS protection, rate limiting
- **Resource Usage:** Minimal dependencies, production-only installs

## TypeScript Best Practices

### Type Safety

- **Strict Mode:** Always use strict TypeScript settings
- **No Any:** Avoid `any` type, use `unknown` for truly unknown types
- **Type Imports:** Use `import type` for type-only imports
- **Non-null Assertions:** Use `!` sparingly, prefer type guards
- **Return Types:** Explicitly declare return types for public functions

### Import Conventions

```typescript
// ✅ Correct - Type-only imports
import type { Request, Response } from 'express'
import type { ApiResponse } from '../types/index.js'

// ✅ Correct - Value imports
import { Router } from 'express'
import { config } from '../config/env.js'

// ✅ Correct - .js extension for local modules (required for Node.js ESM)
import { sendEmail } from '../services/emailService.js'

// ❌ Incorrect - .ts extension
import { sendEmail } from '../services/emailService.ts'

// ❌ Incorrect - missing extension
import { sendEmail } from '../services/emailService'
```

### Error Handling with Types

```typescript
// ✅ Proper error handling with type checking
try {
	const result = await someAsyncOperation()
	res.status(200).json({ success: true, data: result })
} catch (error) {
	const errorMessage = error instanceof Error ? error.message : 'Unknown error'
	res.status(500).json({
		success: false,
		message: 'Operation failed',
		error: errorMessage,
	})
}

// ❌ Incorrect - accessing error.message without type check
try {
	await someAsyncOperation()
} catch (error) {
	res.status(500).json({ error: error.message }) // TypeScript error!
}
```

### Interface vs Type

- **Interfaces:** Use for object shapes, API contracts, configuration
- **Types:** Use for unions, intersections, mapped types, utility types
- **Consistency:** Prefer interfaces for extensibility, types for composition

```typescript
// ✅ Use interface for object shapes
interface ApiResponse<T = unknown> {
	success: boolean
	message?: string
	data?: T
	error?: string
}

// ✅ Use type for unions
type LogLevel = 'info' | 'warn' | 'error'

// ✅ Use type for utility types
type ReadonlyConfig = Readonly<AppConfig>
```

## When Adding New Features

### Route Addition Checklist

1. Create route file in `src/routes/` with Router pattern and TypeScript types
2. Define request/response interfaces in `src/types/index.ts` if needed
3. Import and apply appropriate middleware with type annotations
4. Add route to `src/app.ts` imports and middleware stack
5. Follow async/await pattern with typed try-catch error handling
6. Return consistent JSON response format using typed interfaces
7. Run `npm run build` and `npm run type-check` to verify compilation

### Service Layer Guidelines

1. Create service file in `src/services/` for business logic with TypeScript types
2. Define service interfaces and types in `src/types/index.ts`
3. Use typed configuration from `src/config/env.ts`
4. Export named functions with explicit parameter and return type annotations
5. Include proper error handling with meaningful typed error responses
6. Add connection/verification functions for external services with typed returns
7. Use TypeScript strict mode features (non-null assertions, strict function types)

### Middleware Patterns

1. Create middleware file in `src/middleware/` with TypeScript types
2. Import required dependencies with type definitions
3. Use typed configuration from `src/config/env.ts`
4. Export configured middleware function with proper Express types
5. Apply at route level rather than globally when possible
6. Follow Express middleware signature with TypeScript types (req: Request, res: Response, next: NextFunction)

### Testing Endpoints

```bash
# Health Check
curl http://localhost:3000/health

# Email Endpoint (requires rate limiting consideration)
curl -X POST http://localhost:3000/send-email \
  -H "Content-Type: application/json" \
  -d '{"from":"test@example.com","message":"Test message","project":"Test Project"}'
```

## TypeScript Development Workflow

### Development Cycle

1. **Start Development:** `npm run dev` (uses tsx for instant TypeScript execution)
2. **Check Types:** `npm run type-check` (verify types without compilation)
3. **Format Code:** `npm run format` (Prettier formatting)
4. **Lint Code:** `npm run lint` (TypeScript-aware ESLint)
5. **Build for Production:** `npm run build` (compile to dist/)
6. **Test Build:** `npm start` (run compiled JavaScript)

### Common TypeScript Errors

**Error:** `Cannot find module './file.js' or its corresponding type declarations`

- **Solution:** Ensure import uses `.js` extension (not `.ts`), TypeScript handles this

**Error:** `Property 'x' does not exist on type 'y'`

- **Solution:** Add proper type definitions in `src/types/index.ts`

**Error:** `Argument of type 'string | undefined' is not assignable to parameter of type 'string'`

- **Solution:** Use non-null assertion `!` or type guard after validation

**Error:** `'await' expressions are only allowed within async functions`

- **Solution:** Ensure function is declared as `async`

### Module Resolution

- **tsconfig.json:** Uses `"moduleResolution": "Bundler"` for modern tooling
- **Import Extensions:** Always use `.js` in imports (TypeScript transpiles .ts → .js)
- **Type-only Imports:** Use `import type` to avoid runtime overhead
- **Path Mapping:** Not used; prefer relative imports for clarity

This backend serves as a focused API layer for email functionality with strong security practices, proper TypeScript type safety, and production-ready deployment patterns.
