name: Epic Manager

on:
  issues:
    types:
      - closed
      - reopened
      - edited
      - labeled
      - unlabeled
  workflow_dispatch:
    inputs:
      issue_number:
        description: 'Issue number to process'
        required: true
        type: number

jobs:
  manage-epics:
    runs-on: ubuntu-latest
    permissions:
      issues: write
      contents: read
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v6

      - name: Setup Node.js
        uses: actions/setup-node@v6
        with:
          node-version: '20'

      - name: Manage Epic Issues
        uses: actions/github-script@v8
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const { owner, repo } = context.repo;
            let triggeredIssue = context.payload.issue;

            // If manually triggered with issue_number input, fetch that issue
            if (context.eventName === 'workflow_dispatch' && context.payload.inputs?.issue_number) {
              const issueNumber = parseInt(context.payload.inputs.issue_number);
              console.log(`Manual run for issue #${issueNumber}`);
              
              const issueResponse = await github.rest.issues.get({
                owner,
                repo,
                issue_number: issueNumber
              });
              
              triggeredIssue = issueResponse.data;
            }

            if (!triggeredIssue) {
              console.log('No issue in context, skipping');
              return;
            }

            console.log(`Triggered by issue #${triggeredIssue.number}: ${triggeredIssue.title}`);

            // Initialize summary output
            let summary = `## üéØ Parent Issue Management\n\n`;
            summary += `**Triggered by:** #${triggeredIssue.number} - ${triggeredIssue.title}\n\n`;

            // Helper function to get parent issue number from GitHub's native parent field
            function getParentIssueNumber(issue) {
              // Check for GitHub's native parent_issue_url field
              if (issue.parent_issue_url) {
                const urlMatch = issue.parent_issue_url.match(/\/issues\/(\d+)$/);
                if (urlMatch) {
                  return parseInt(urlMatch[1]);
                }
              }
              return null;
            }

            // Collect all parent issues recursively
            const parentsToCheck = [];
            const visited = new Set();
            let currentIssue = triggeredIssue;

            while (currentIssue) {
              const parentNumber = getParentIssueNumber(currentIssue);
              
              if (!parentNumber || visited.has(parentNumber)) {
                break;
              }

              visited.add(parentNumber);
              
              try {
                const parentIssue = await github.rest.issues.get({
                  owner,
                  repo,
                  issue_number: parentNumber
                });

                console.log(`Found parent #${parentNumber}: ${parentIssue.data.title}`);
                parentsToCheck.push(parentIssue.data);
                currentIssue = parentIssue.data;
              } catch (error) {
                console.log(`Error fetching parent #${parentNumber}: ${error.message}`);
                break;
              }
            }

            if (parentsToCheck.length === 0) {
              console.log('No parent issues found, skipping');
              summary += `### ‚ÑπÔ∏è No parent issues found\n\n`;
              summary += `This issue has no parent relationships.\n`;
              await core.summary.addRaw(summary).write();
              return;
            }

            console.log(`\nProcessing ${parentsToCheck.length} parent issue(s)...`);
            summary += `### üìã Found ${parentsToCheck.length} parent issue(s)\n\n`;

            // Get all issues in the repository once
            const allIssues = await github.rest.issues.listForRepo({
              owner,
              repo,
              state: 'all',
              per_page: 100
            });

            // Process each parent issue
            for (const parentIssue of parentsToCheck) {
              console.log(`\n--- Processing parent #${parentIssue.number}: ${parentIssue.title} ---`);
              summary += `\n#### #${parentIssue.number} - ${parentIssue.title}\n\n`;

              // Find child issues (issues that have this parent as their parent)
              const linkedIssues = [];

              for (const issue of allIssues.data) {
                if (issue.number === parentIssue.number) continue;

                try {
                  // Check GitHub's native parent_issue_url field
                  if (issue.parent_issue_url) {
                    const urlMatch = issue.parent_issue_url.match(/\/issues\/(\d+)$/);
                    if (urlMatch && parseInt(urlMatch[1]) === parentIssue.number) {
                      linkedIssues.push(issue);
                    }
                  }
                } catch (error) {
                  console.log(`  Error checking issue #${issue.number}: ${error.message}`);
                }
              }

              console.log(`Found ${linkedIssues.length} linked issue(s)`);

              if (linkedIssues.length === 0) {
                console.log(`No linked issues found for #${parentIssue.number}, skipping state management`);
                summary += `- **Status:** ‚ö†Ô∏è No child issues found\n`;
                continue;
              }

              // Count open linked issues
              const openLinkedIssues = linkedIssues.filter(issue => issue.state === 'open');
              const closedLinkedIssues = linkedIssues.filter(issue => issue.state === 'closed');

              console.log(`  Open: ${openLinkedIssues.length}, Closed: ${closedLinkedIssues.length}`);
              summary += `- **Child Issues:** ${linkedIssues.length} total (${openLinkedIssues.length} open, ${closedLinkedIssues.length} closed)\n`;

              // Determine if parent should be open or closed
              const shouldBeOpen = openLinkedIssues.length > 0;
              const isCurrentlyOpen = parentIssue.state === 'open';

              if (shouldBeOpen && !isCurrentlyOpen) {
                // Reopen the parent
                console.log(`Reopening #${parentIssue.number} (has ${openLinkedIssues.length} open linked issue(s))`);
                summary += `- **Action:** üîÑ **Reopened** (has ${openLinkedIssues.length} open child issue(s))\n`;
                summary += `  - Open issues: ${openLinkedIssues.map(i => `#${i.number}`).join(', ')}\n`;

                await github.rest.issues.update({
                  owner,
                  repo,
                  issue_number: parentIssue.number,
                  state: 'open'
                });

                // Add a comment explaining why it was reopened
                await github.rest.issues.createComment({
                  owner,
                  repo,
                  issue_number: parentIssue.number,
                  body: `üîÑ This issue was automatically reopened because it has ${openLinkedIssues.length} open linked issue(s):\n\n${openLinkedIssues.map(i => `- #${i.number} ${i.title}`).join('\n')}`
                });

              } else if (!shouldBeOpen && isCurrentlyOpen) {
                // Close the parent
                console.log(`Closing #${parentIssue.number} (all ${linkedIssues.length} linked issue(s) are closed)`);
                summary += `- **Action:** ‚úÖ **Closed** (all ${linkedIssues.length} child issue(s) are closed)\n`;

                await github.rest.issues.update({
                  owner,
                  repo,
                  issue_number: parentIssue.number,
                  state: 'closed'
                });

                // Add a comment explaining why it was closed
                await github.rest.issues.createComment({
                  owner,
                  repo,
                  issue_number: parentIssue.number,
                  body: `‚úÖ This issue was automatically closed because all ${linkedIssues.length} linked issue(s) are now closed.`
                });

              } else {
                console.log(`State is correct (should be ${shouldBeOpen ? 'open' : 'closed'}, is ${isCurrentlyOpen ? 'open' : 'closed'})`);
                summary += `- **Action:** ‚ÑπÔ∏è No change needed (already ${isCurrentlyOpen ? 'open' : 'closed'})\n`;
              }
            }

            console.log('\n‚ú® Parent issue management complete');
            
            // Write summary to workflow output
            summary += `\n---\n‚ú® **Parent issue management complete!**\n`;
            await core.summary.addRaw(summary).write();
