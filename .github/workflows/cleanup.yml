name: Cleanup GHCR untagged images

on:
  schedule:
    - cron: '0 0 1 * *'
  workflow_dispatch:
    inputs:
      dry_run:
        description: 'If true, only log what would be deleted'
        required: false
        default: 'false'
      additional_package_names:
        description: 'Optional extra GHCR package names to include (space or comma separated)'
        required: false
        default: ''

permissions:
  contents: read
  packages: write

jobs:
  prune-untagged:
    name: Delete untagged GHCR versions
    runs-on: ubuntu-latest
    timeout-minutes: 15
    concurrency:
      group: ghcr-prune-${{ github.repository }}
      cancel-in-progress: false
    env:
      ADDITIONAL_PACKAGE_NAMES: ${{ github.event.inputs.additional_package_names }}
      DRY_RUN: ${{ github.event.inputs.dry_run }}
    steps:
      - name: Checkout (shallow)
        uses: actions/checkout@v4
        with:
          fetch-depth: 1

      - name: Delete untagged container versions from GHCR
        uses: actions/github-script@v7
        env:
          ADDITIONAL_PACKAGE_NAMES: ${{ env.ADDITIONAL_PACKAGE_NAMES }}
          DRY_RUN: ${{ env.DRY_RUN }}
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const isOrg = (context.payload?.repository?.owner?.type || process.env.GITHUB_REPOSITORY_OWNER_TYPE || '').toLowerCase() === 'organization';
            const owner = context.repo.owner;
            const repo = context.repo.repo.toLowerCase();
            const extras = (process.env.ADDITIONAL_PACKAGE_NAMES || '')
              .split(/[\s,]+/)
              .map(s => s.trim())
              .filter(Boolean)
              .map(s => s.toLowerCase());
            const packageNames = [...new Set([repo, ...extras])];
            const dryRun = String(process.env.DRY_RUN || 'false').toLowerCase() === 'true';

            const base = isOrg ? `/orgs/${owner}` : `/users/${owner}`;
            const headers = { 'X-GitHub-Api-Version': '2022-11-28' };

            let totalDeleted = 0;

            for (const pkg of packageNames) {
              core.info(`Scanning package '${pkg}' in ${isOrg ? 'org' : 'user'} '${owner}'...`);
              let page = 1;
              let deletedForPkg = 0;
              while (true) {
                let versions;
                try {
                  const res = await github.request('GET ' + base + '/packages/{package_type}/{package_name}/versions', {
                    package_type: 'container',
                    package_name: pkg,
                    per_page: 100,
                    page,
                    headers
                  });
                  versions = res.data || [];
                } catch (e) {
                  core.warning(`Failed to list versions for '${pkg}' (page ${page}): ${e.message}`);
                  break; // Stop scanning this package if listing fails
                }

                if (!versions.length) break;

                for (const v of versions) {
                  const tags = (v?.metadata?.container?.tags) || [];
                  if (!tags.length) {
                    if (dryRun) {
                      core.info(`[DRY RUN] Would delete version id=${v.id} created_at=${v.created_at}`);
                    } else {
                      try {
                        await github.request('DELETE ' + base + '/packages/{package_type}/{package_name}/versions/{package_version_id}', {
                          package_type: 'container',
                          package_name: pkg,
                          package_version_id: v.id,
                          headers
                        });
                        core.info(`Deleted untagged version id=${v.id}`);
                        deletedForPkg++;
                        totalDeleted++;
                      } catch (delErr) {
                        core.warning(`Failed to delete version id=${v.id}: ${delErr.message}`);
                      }
                    }
                  }
                }

                page++;
              }
              core.info(`Package '${pkg}': ${dryRun ? '[DRY RUN] ' : ''}${deletedForPkg} untagged versions ${dryRun ? 'would be ' : ''}deleted.`);
            }

            core.summary.addHeading('GHCR untagged cleanup');
            core.summary.addRaw(`${dryRun ? 'DRY RUN: ' : ''}Total untagged versions ${dryRun ? 'that would be ' : ''}deleted: ${totalDeleted}`);
            await core.summary.write();

            core.setOutput('deleted', totalDeleted);
